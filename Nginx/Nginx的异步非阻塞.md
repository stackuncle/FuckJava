## 同步与异步
### 同步与异步的理解
**同步与异步的重点在消息通知的方式上，也就是调用结果通知的方式。**
同步：当一个同步调用发出去后，调用者要一直等待调用结果的通知后，才能进行后续的执行。
异步：当一个异步调用发出去后，调用者不能立即得到调用结果的返回。
异步调用，要想获得结果，一般有两种方式：
1、主动轮询异步调用的结果;
2、被调用方通过callback来通知调用方调用结果。

### 生活实例
同步取快递：小明收到快递将送达的短信，在楼下一直等到快递送达。
异步取快递：小明收到快递将送达的短信，快递到楼下后，小明再下楼去取。
异步取快递，小明知道快递到达楼下有两种方式：1、不停的电话问快递小哥到了没有，即主动轮询；2、快递小哥到楼下后，打电话通知小明，然后小明下楼取快递，即回调通知。

## 阻塞和非阻塞
### 阻塞与非阻塞的理解
**阻塞与非阻塞的重点在于进/线程等待消息时候的行为，也就是在等待消息的时候，当前进/线程是挂起状态，还是非挂起状态。 **
- 阻塞阻塞调用在发出去后，在消息返回之前，当前进/线程会被挂起，直到有消息返回，当前进/线程才会被激活
- 非阻塞非阻塞调用在发出去后，不会阻塞当前进/线程，而会立即返回。

### 生活实例
阻塞取快递：小明收到快递即将送达的信息后，什么事都不做，一直专门等快递。
非阻塞取快递：小明收到快递即将送达的信息后，等快递的时候，还一边敲代码、一边刷微信。

**同步与异步，重点在于消息通知的方式；阻塞与非阻塞，重点在于等消息时候的行为。**
所以，就有了下面4种组合方式
```
1. 同步阻塞：小明收到信息后，啥都不干，等快递；
2. 同步非阻塞：小明收到信息后，边刷微博，边等着取快递；
3. 异步阻塞：小明收到信息后，啥都不干，一直等着快递员通知他取快递；
4. 异步非阻塞：小明收到信息后，边刷着微博，边等快递员通知他取快递。
```
大部分程序的I/O模型都是**同步阻塞**的，单个进程每次只在一个文件描述符上执行I/O操作，每次I/O系统调用都会阻塞，直到完成数据传输。
传统的服务器采用的就是同步阻塞的多进程模型。一个server采用一个进程负责一个request的方式，一个进程负责一个request，直到会话结束。进程数就是并发数，而操作系统支持的进程数是有限的，且进程数越多，调度的开销也越大，因此无法面对高并发。

Nginx采用了**异步非阻塞**的方式工作。那么Nginx是如何实现异步非阻塞的呢？那得先了解一下I/O多路复用。

## I/O多路复用
所谓的I/O复用，就是多个I/O可以复用一个进程。I/O多路复用允许进程同时检查多个fd，以找出其中可执行I/O操作的fd。
系统调用select()和poll()来执行I/O多路复用。在Linux2.6中引入的epoll()是select()的升级版，提供了更高的性能。通过I/O复用，我们可以在一个进程处理大量的并发I/O。

### 初级版I/O复用
比如一个进程接受了10000个连接，这个进程每次从头到尾的问一遍这10000个连接：“有I/O事件没？有的话就交给我处理，没有的话我一会再来问一遍。”然后进程就一直从头到尾问这10000个连接，如果这10000个连接都没有I/O事件，就会造成CPU的空转，并且效率也很低，不好不好。

那么，如果发明一个代理，每次能够知道哪个连接有了I/O流事件，不就可以避免无意义的空转了吗？为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。

### 升级版I/O复用 
#### select() 
select可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。
```
while true {
  select(streams[])
  for i in streams[] {
      if i has data
          read until unavailable
  }
}
```

**select()采用轮询的方式来检查fd是否就绪，当fd数量较多时，性能欠佳**。因为从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。--from 知乎

#### 生活实例
小明家楼下有一个收发室，每次有快递到了就先代收，但收发室也不知道那个是小明的快递；但小明去取的时候，要查询所有代收的快递。

### 高级版I/O复用 
#### epoll() 
epoll能更高效的检查大量fd，UNIX中提供了类似功能的kqueue调用。
epoll可以理解为event poll，不同于忙轮询和无差别轮询，**当连接有I/O流事件产生的时候，epoll就会去告诉进程哪个连接有I/O流事件产生，然后进程就去处理这个事件**。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I/O事件的流的个数，也有认为O(1)的）

#### 生活实例
小明家楼下有一个收发室，每次有快递到了，就先代收并做了标记；然后通知小明去取送给小明的快递。

## Nginx的异步非阻塞
Nginx配置`use epoll`后，以**异步非阻塞方式**工作，能够轻松处理百万级的并发连接。
```
events {
    worker_connections  1024;
    use kqueue;  # 在Linux中配置：use epoll;
}
```
在一个Web服务中，延迟最多的就是等待网络传输。nginx在启动后，会有一个master进程和多个worker进程。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。而基本的网络事件，则是放在worker进程中来处理了。在一个请求需要等待的时候，worker可以空闲出来处理其他的请求，少数几个worker进程就能够处理大量的并发。

举例来说：同样的4个进程，如果采用一个进程负责一个request的方式；那么，同时进来4个request之后，每个进程就负责其中一个，直至会话关闭。期间，如果有第5个request进来了。就无法及时反应了，因为4个进程都没干完活呢，因此，一般有个调度进程，每当新进来了一个request，就新开个进程来处理。

nginx不这样，每进来一个request，会有一个worker进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方。比如向后端服务器转发request，并等待请求返回。那么，这个处理的worker不会这么傻等着，他会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。

## 总结
web server刚好属于网络io密集型应用，不算是计算密集型。web  server的这种性质决定了每个request的大部份时间都消耗在网络传输中，实际上花费在server机器上的时间片不多。异步非阻塞，使用epoll，和大量细节处的优化，这就是Nginx几个进程就解决高并发的秘密所在。

## 参考
- [深入理解Nginx](https://s.click.taobao.com/lMHywKw)
